/*! For license information please see 3093.chunk.3406eac4db95867d0edf.js.LICENSE.txt */
"use strict";(self.webpackChunkultimate_jekyll=self.webpackChunkultimate_jekyll||[]).push([[3093],{3093:(e,t,r)=>{r.d(t,{ReCaptchaEnterpriseProvider:()=>X,initializeAppCheck:()=>Y});var n=r(9943),o=r(1711),i=r(3047),a=r(722);const s=new Map,c={activated:!1,tokenObservers:[]},h={initialized:!1,enabled:!1};function l(e){return s.get(e)||{...c}}function p(){return h}const u="https://content-firebaseappcheck.googleapis.com/v1",d="exchangeDebugToken",f={OFFSET_DURATION:3e5,RETRIAL_MIN_WAIT:3e4,RETRIAL_MAX_WAIT:96e4};class g{constructor(e,t,r,n,o){if(this.operation=e,this.retryPolicy=t,this.getWaitDuration=r,this.lowerBound=n,this.upperBound=o,this.pending=null,this.nextErrorWaitInterval=n,n>o)throw new Error("Proactive refresh lower bound greater than upper bound!")}start(){this.nextErrorWaitInterval=this.lowerBound,this.process(!0).catch(()=>{})}stop(){this.pending&&(this.pending.reject("cancelled"),this.pending=null)}isRunning(){return!!this.pending}async process(e){this.stop();try{this.pending=new i.cY,this.pending.promise.catch(e=>{}),await(t=this.getNextRun(e),new Promise(e=>{setTimeout(e,t)})),this.pending.resolve(),await this.pending.promise,this.pending=new i.cY,this.pending.promise.catch(e=>{}),await this.operation(),this.pending.resolve(),await this.pending.promise,this.process(!0).catch(()=>{})}catch(e){this.retryPolicy(e)?this.process(!1).catch(()=>{}):this.stop()}var t}getNextRun(e){if(e)return this.nextErrorWaitInterval=this.lowerBound,this.getWaitDuration();{const e=this.nextErrorWaitInterval;return this.nextErrorWaitInterval*=2,this.nextErrorWaitInterval>this.upperBound&&(this.nextErrorWaitInterval=this.upperBound),e}}}const k=new i.FA("appCheck","AppCheck",{"already-initialized":"You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.","use-before-activation":"App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.","fetch-network-error":"Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.","fetch-parse-error":"Fetch client could not parse response. Original error: {$originalErrorMessage}.","fetch-status-error":"Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.","storage-open":"Error thrown when opening storage. Original error: {$originalErrorMessage}.","storage-get":"Error thrown when reading from storage. Original error: {$originalErrorMessage}.","storage-set":"Error thrown when writing to storage. Original error: {$originalErrorMessage}.","recaptcha-error":"ReCAPTCHA error.","initial-throttle":"{$httpStatus} error. Attempts allowed again after {$time}",throttled:"Requests throttled due to previous {$httpStatus} error. Attempts allowed again after {$time}"});function w(e=!1){return e?self.grecaptcha?.enterprise:self.grecaptcha}function m(e){if(!l(e).activated)throw k.create("use-before-activation",{appName:e.name})}function E(e){const t=Math.round(e/1e3),r=Math.floor(t/86400),n=Math.floor((t-3600*r*24)/3600),o=Math.floor((t-3600*r*24-3600*n)/60),i=t-3600*r*24-3600*n-60*o;let a="";return r&&(a+=b(r)+"d:"),n&&(a+=b(n)+"h:"),a+=b(o)+"m:"+b(i)+"s",a}function b(e){return 0===e?"00":e>=10?e.toString():"0"+e}async function v({url:e,body:t},r){const n={"Content-Type":"application/json"},o=r.getImmediate({optional:!0});if(o){const e=await o.getHeartbeatsHeader();e&&(n["X-Firebase-Client"]=e)}const i={method:"POST",body:JSON.stringify(t),headers:n};let a,s;try{a=await fetch(e,i)}catch(e){throw k.create("fetch-network-error",{originalErrorMessage:e?.message})}if(200!==a.status)throw k.create("fetch-status-error",{httpStatus:a.status});try{s=await a.json()}catch(e){throw k.create("fetch-parse-error",{originalErrorMessage:e?.message})}const c=s.ttl.match(/^([\d.]+)(s)$/);if(!c||!c[2]||isNaN(Number(c[1])))throw k.create("fetch-parse-error",{originalErrorMessage:`ttl field (timeToLive) is not in standard Protobuf Duration format: ${s.ttl}`});const h=1e3*Number(c[1]),l=Date.now();return{token:s.token,expireTimeMillis:l+h,issuedAtTimeMillis:l}}function T(e,t){const{projectId:r,appId:n,apiKey:o}=e.options;return{url:`${u}/projects/${r}/apps/${n}:${d}?key=${o}`,body:{debug_token:t}}}const A="firebase-app-check-database",y=1,C="firebase-app-check-store",P="debug-token";let I=null;function _(){return I||(I=new Promise((e,t)=>{try{const r=indexedDB.open(A,y);r.onsuccess=t=>{e(t.target.result)},r.onerror=e=>{t(k.create("storage-open",{originalErrorMessage:e.target.error?.message}))},r.onupgradeneeded=e=>{const t=e.target.result;0===e.oldVersion&&t.createObjectStore(C,{keyPath:"compositeKey"})}}catch(e){t(k.create("storage-open",{originalErrorMessage:e?.message}))}}),I)}async function R(e,t){const r=(await _()).transaction(C,"readwrite"),n=r.objectStore(C).put({compositeKey:e,value:t});return new Promise((e,t)=>{n.onsuccess=t=>{e()},r.onerror=e=>{t(k.create("storage-set",{originalErrorMessage:e.target.error?.message}))}})}async function S(e){const t=(await _()).transaction(C,"readonly"),r=t.objectStore(C).get(e);return new Promise((e,n)=>{r.onsuccess=t=>{const r=t.target.result;e(r?r.value:void 0)},t.onerror=e=>{n(k.create("storage-get",{originalErrorMessage:e.target.error?.message}))}})}function x(e){return`${e.options.appId}-${e.name}`}const D=new a.Vy("@firebase/app-check");function M(e,t){return(0,i.zW)()?function(e,t){return R(x(e),t)}(e,t).catch(e=>{D.warn(`Failed to write token to IndexedDB. Error: ${e}`)}):Promise.resolve()}function $(){return p().enabled}async function N(){const e=p();if(e.enabled&&e.token)return e.token.promise;throw Error("\n            Can't get debug token in production mode.\n        ")}const O={error:"UNKNOWN_ERROR"};async function z(e,t=!1,r=!1){const n=e.app;m(n);const o=l(n);let i,a=o.token;if(a&&!W(a)&&(o.token=void 0,a=void 0),!a){const e=await o.cachedTokenPromise;e&&(W(e)?a=e:await M(n,void 0))}if(!t&&a&&W(a))return{token:a.token};let s,c=!1;if($())try{o.exchangeTokenPromise||(o.exchangeTokenPromise=v(T(n,await N()),e.heartbeatServiceProvider).finally(()=>{o.exchangeTokenPromise=void 0}),c=!0);const t=await o.exchangeTokenPromise;return await M(n,t),o.token=t,{token:t.token}}catch(e){return"appCheck/throttled"===e.code||"appCheck/initial-throttle"===e.code?D.warn(e.message):r&&D.error(e),j(e)}try{o.exchangeTokenPromise||(o.exchangeTokenPromise=o.provider.getToken().finally(()=>{o.exchangeTokenPromise=void 0}),c=!0),a=await l(n).exchangeTokenPromise}catch(e){"appCheck/throttled"===e.code||"appCheck/initial-throttle"===e.code?D.warn(e.message):r&&D.error(e),i=e}return a?i?s=W(a)?{token:a.token,internalError:i}:j(i):(s={token:a.token},o.token=a,await M(n,a)):s=j(i),c&&H(n,s),s}function B(e,t,r,n){const{app:o}=e,i=l(o),a={next:r,error:n,type:t};if(i.tokenObservers=[...i.tokenObservers,a],i.token&&W(i.token)){const t=i.token;Promise.resolve().then(()=>{r({token:t.token}),F(e)}).catch(()=>{})}i.cachedTokenPromise.then(()=>F(e))}function K(e,t){const r=l(e),n=r.tokenObservers.filter(e=>e.next!==t);0===n.length&&r.tokenRefresher&&r.tokenRefresher.isRunning()&&r.tokenRefresher.stop(),r.tokenObservers=n}function F(e){const{app:t}=e,r=l(t);let n=r.tokenRefresher;n||(n=function(e){const{app:t}=e;return new g(async()=>{let r;if(r=l(t).token?await z(e,!0):await z(e),r.error)throw r.error;if(r.internalError)throw r.internalError},()=>!0,()=>{const e=l(t);if(e.token){let t=e.token.issuedAtTimeMillis+.5*(e.token.expireTimeMillis-e.token.issuedAtTimeMillis)+3e5;const r=e.token.expireTimeMillis-3e5;return t=Math.min(t,r),Math.max(0,t-Date.now())}return 0},f.RETRIAL_MIN_WAIT,f.RETRIAL_MAX_WAIT)}(e),r.tokenRefresher=n),!n.isRunning()&&r.isTokenAutoRefreshEnabled&&n.start()}function H(e,t){const r=l(e).tokenObservers;for(const e of r)try{"EXTERNAL"===e.type&&null!=t.error?e.error(t.error):e.next(t)}catch(e){}}function W(e){return e.expireTimeMillis-Date.now()>0}function j(e){return{token:(t=O,i.K3.encodeString(JSON.stringify(t),!1)),error:e};var t}class L{constructor(e,t){this.app=e,this.heartbeatServiceProvider=t}_delete(){const{tokenObservers:e}=l(this.app);for(const t of e)K(this.app,t.next);return Promise.resolve()}}function U(e,t){const r=new i.cY;l(e).reCAPTCHAState={initialized:r};const n=function(e){const t=`fire_app_check_${e.name}`,r=document.createElement("div");return r.id=t,r.style.display="none",document.body.appendChild(r),t}(e),o=w(!0);return o?q(e,t,o,n,r):function(){const o=document.createElement("script");o.src="https://www.google.com/recaptcha/enterprise.js",o.onload=()=>{const o=w(!0);if(!o)throw new Error("no recaptcha");q(e,t,o,n,r)},document.head.appendChild(o)}(),r.promise}function q(e,t,r,n,o){r.ready(()=>{!function(e,t,r,n){const o=r.render(n,{sitekey:t,size:"invisible",callback:()=>{l(e).reCAPTCHAState.succeeded=!0},"error-callback":()=>{l(e).reCAPTCHAState.succeeded=!1}}),i=l(e);i.reCAPTCHAState={...i.reCAPTCHAState,widgetId:o}}(e,t,r,n),o.resolve(r)})}class X{constructor(e){this._siteKey=e,this._throttleData=null}async getToken(){!function(e){if(e&&Date.now()-e.allowRequestsAfter<=0)throw k.create("throttled",{time:E(e.allowRequestsAfter-Date.now()),httpStatus:e.httpStatus})}(this._throttleData);const e=await async function(e){m(e);const t=l(e).reCAPTCHAState,r=await t.initialized.promise;return new Promise((t,n)=>{const o=l(e).reCAPTCHAState;r.ready(()=>{t(r.execute(o.widgetId,{action:"fire_app_check"}))})})}(this._app).catch(e=>{throw k.create("recaptcha-error")});if(!l(this._app).reCAPTCHAState?.succeeded)throw k.create("recaptcha-error");let t;try{t=await v(function(e,t){const{projectId:r,appId:n,apiKey:o}=e.options;return{url:`${u}/projects/${r}/apps/${n}:exchangeRecaptchaEnterpriseToken?key=${o}`,body:{recaptcha_enterprise_token:t}}}(this._app,e),this._heartbeatServiceProvider)}catch(e){throw e.code?.includes("fetch-status-error")?(this._throttleData=function(e,t){if(404===e||403===e)return{backoffCount:1,allowRequestsAfter:Date.now()+864e5,httpStatus:e};{const r=t?t.backoffCount:0,n=(0,i.p9)(r,1e3,2);return{backoffCount:r+1,allowRequestsAfter:Date.now()+n,httpStatus:e}}}(Number(e.customData?.httpStatus),this._throttleData),k.create("initial-throttle",{time:E(this._throttleData.allowRequestsAfter-Date.now()),httpStatus:this._throttleData.httpStatus})):e}return this._throttleData=null,t}initialize(e){this._app=e,this._heartbeatServiceProvider=(0,n.j6)(e,"heartbeat"),U(e,this._siteKey).catch(()=>{})}isEqual(e){return e instanceof X&&this._siteKey===e._siteKey}}function Y(e=(0,n.Sx)(),t){e=(0,i.Ku)(e);const r=(0,n.j6)(e,"app-check");if(p().initialized||function(){const e=(0,i.mS)(),t=p();if(t.initialized=!0,"string"!=typeof e.FIREBASE_APPCHECK_DEBUG_TOKEN&&!0!==e.FIREBASE_APPCHECK_DEBUG_TOKEN)return;t.enabled=!0;const r=new i.cY;t.token=r,"string"==typeof e.FIREBASE_APPCHECK_DEBUG_TOKEN?r.resolve(e.FIREBASE_APPCHECK_DEBUG_TOKEN):r.resolve(async function(){let e;try{e=await S(P)}catch(e){}if(e)return e;{const e=crypto.randomUUID();return(t=e,R(P,t)).catch(e=>D.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`)),e}var t}())}(),$()&&N().then(e=>console.log(`App Check debug token: ${e}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`)),r.isInitialized()){const n=r.getImmediate(),o=r.getOptions();if(o.isTokenAutoRefreshEnabled===t.isTokenAutoRefreshEnabled&&o.provider.isEqual(t.provider))return n;throw k.create("already-initialized",{appName:e.name})}const o=r.initialize({options:t});return function(e,t,r=!1){const n=function(e,t){return s.set(e,t),s.get(e)}(e,{...c});n.activated=!0,n.provider=t,n.cachedTokenPromise=async function(e){if((0,i.zW)()){let t;try{t=await function(e){return S(x(e))}(e)}catch(e){D.warn(`Failed to read token from IndexedDB. Error: ${e}`)}return t}}(e).then(t=>(t&&W(t)&&(n.token=t,H(e,{token:t.token})),t)),n.isTokenAutoRefreshEnabled=r&&e.automaticDataCollectionEnabled,!e.automaticDataCollectionEnabled&&r&&D.warn("`isTokenAutoRefreshEnabled` is true but `automaticDataCollectionEnabled` was set to false during `initializeApp()`. This blocks automatic token refresh."),n.provider.initialize(e)}(e,t.provider,t.isTokenAutoRefreshEnabled),l(e).isTokenAutoRefreshEnabled&&B(o,"INTERNAL",()=>{}),o}const G="app-check-internal";(0,n.om)(new o.uA("app-check",e=>{return t=e.getProvider("app").getImmediate(),r=e.getProvider("heartbeat"),new L(t,r);var t,r},"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e,t,r)=>{e.getProvider(G).initialize()})),(0,n.om)(new o.uA(G,e=>{return t=e.getProvider("app-check").getImmediate(),{getToken:e=>z(t,e),getLimitedUseToken:()=>async function(e){const t=e.app;m(t);const{provider:r}=l(t);if($()){const r=await N(),{token:n}=await v(T(t,r),e.heartbeatServiceProvider);return{token:n}}{const{token:e}=await r.getToken();return{token:e}}}(t),addTokenListener:e=>B(t,"INTERNAL",e),removeTokenListener:e=>K(t.app,e)};var t},"PUBLIC").setInstantiationMode("EXPLICIT")),(0,n.KO)("@firebase/app-check","0.11.0")}}]);